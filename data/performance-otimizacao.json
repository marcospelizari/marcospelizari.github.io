{
    "title": "Performance e Otimização",
    "description": "Técnicas para tornar aplicações Java backend rápidas e escaláveis.",
    "subsections": [
        {
            "subtitle": "Fundamentos de Performance",
            "description": "Como melhorar velocidade e eficiência.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Performance reduz latência e uso de recursos como CPU e memória. Otimize consultas, use cache e gerencie o GC (Garbage Collector).",
                    "code": ""
                }
            ]
        },
        {
            "subtitle": "Otimização de Consultas",
            "description": "Como acelerar acesso ao banco.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Use índices e JOINs no JPA (Java Persistence API) para evitar o problema N+1. Consulte apenas dados necessários.",
                    "code": "@Repository\npublic interface ProdutoRepository extends JpaRepository<Produto, Long> {\n    @Query(\"SELECT p FROM Produto p WHERE p.categoria = :categoria\")\n    List<Produto> findByCategoria(@Param(\"categoria\") String categoria);\n}"
                }
            ]
        },
        {
            "subtitle": "Caching",
            "description": "Como reduzir acessos repetitivos.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Caching armazena dados frequentes na memória com @Cacheable, usando Redis ou Ehcache, para melhorar latência.",
                    "code": "@Service\npublic class ProdutoService {\n    @Cacheable(\"produtos\")\n    public List<Produto> listar() { return repository.findAll(); }\n}"
                }
            ]
        },
        {
            "subtitle": "Assincronismo",
            "description": "Como escalar com operações assíncronas.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Use @Async no Spring para executar tarefas demoradas, como envio de e-mails, sem bloquear a thread principal.",
                    "code": "@Service\npublic class EmailService {\n    @Async\n    public CompletableFuture<Void> enviarEmail(String destinatario) {\n        Thread.sleep(2000);\n        return CompletableFuture.completedFuture(null);\n    }\n}"
                }
            ]
        },
        {
            "subtitle": "Monitoramento",
            "description": "Como acompanhar performance.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Use Prometheus para coletar métricas como latência e VisualVM para monitorar o GC (Garbage Collector) e JVM (Java Virtual Machine).",
                    "code": ""
                }
            ]
        },
        {
            "subtitle": "Recursos para Prática",
            "description": "Ferramentas para aprender otimização.",
            "examples": [
                {
                    "title": "Explicação",
                    "explanation": "Use VisualVM (JVM), JMeter (testes de carga), Redis (cache) e Baeldung (tutoriais).",
                    "code": ""
                }
            ]
        }
    ]
}