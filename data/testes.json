{
    "title": "Testes",
    "description": "Testes são fundamentais para garantir que o código funciona corretamente e é fácil de manter. Este tópico cobre os conceitos básicos de testes unitários e de integração, com foco em ferramentas usadas em Java, como JUnit e Spring Boot Test.",
    "subsections": [
        {
            "subtitle": "O que são testes unitários e por que usá-los?",
            "description": "",
            "examples": [
                {
                    "title": "Explicação",
                    "code": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculadoraTest {\n    @Test\n    public void testSomar() {\n        Calculadora calc = new Calculadora();\n        int resultado = calc.somar(2, 3);\n        assertEquals(5, resultado);\n    }\n}",
                    "explanation": "Resposta Ideal (Júnior): Testes unitários verificam o funcionamento de uma pequena parte do código, como um método, isoladamente. Eles garantem que cada unidade (como uma função de soma) funcione corretamente antes de integrá-la ao sistema. Em Java, usamos frameworks como JUnit para escrever testes unitários, usando anotações como @Test e métodos como assertEquals para verificar resultados esperados. Testes unitários ajudam a encontrar erros cedo, facilitam mudanças no código e aumentam a confiança na aplicação.<br>Resposta Simples: Testes unitários checam se um pedaço pequeno do código, como um método, funciona certo. Usamos JUnit para escrever esses testes."
                }
            ]
        },
        {
            "subtitle": "O que são testes de integração?",
            "description": "",
            "examples": [
                {
                    "title": "Explicação",
                    "code": "import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\npublic class ProdutoServiceTest {\n    @Autowired\n    private ProdutoService service;\n\n    @Test\n    public void testSalvarProduto() {\n        Produto produto = new Produto(\"Notebook\", 5000);\n        Produto salvo = service.salvar(produto);\n        assertNotNull(salvo.getId());\n    }\n}",
                    "explanation": "Resposta Ideal (Júnior): Testes de integração verificam se diferentes partes do sistema, como um serviço e um banco de dados, funcionam bem juntas. Diferente dos testes unitários, que isolam componentes, os testes de integração testam a interação entre eles. Em Java com Spring Boot, usamos o Spring Boot Test com anotações como @SpringBootTest para carregar o contexto da aplicação e testar fluxos completos, como salvar um objeto no banco. Eles são importantes para garantir que o sistema como um todo funciona corretamente.<br>Resposta Simples: Testes de integração checam se várias partes do sistema, como serviço e banco de dados, trabalham bem juntas."
                }
            ]
        },
        {
            "subtitle": "O que é mocking e quando usá-lo?",
            "description": "",
            "examples": [
                {
                    "title": "Explicação",
                    "code": "import org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\npublic class ProdutoServiceTest {\n    @Test\n    public void testSalvarProduto() {\n        ProdutoRepository repo = Mockito.mock(ProdutoRepository.class);\n        ProdutoService service = new ProdutoService(repo);\n        Produto produto = new Produto(\"Celular\", 2000);\n        service.salvar(produto);\n        Mockito.verify(repo).save(produto);\n    }\n}",
                    "explanation": "Resposta Ideal (Júnior): Mocking é a técnica de criar objetos falsos (mocks) que simulam o comportamento de dependências reais, como um banco de dados ou uma API externa. Em Java, usamos bibliotecas como Mockito para criar mocks. Isso é útil em testes unitários, quando queremos testar apenas uma parte do código (como um serviço) sem depender de outros componentes (como um repositório). Mocking economiza tempo, evita configurar sistemas reais e permite testar cenários específicos, como erros.<br>Resposta Simples: Mocking é fingir que uma parte do sistema existe para testar outra parte sozinha, usando ferramentas como Mockito."
                }
            ]
        }
    ]
}