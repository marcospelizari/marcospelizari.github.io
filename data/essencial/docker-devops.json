{
  "title": "Docker e DevOps",
  "description": "Conceitos básicos e práticas modernas de containers e DevOps, com exemplos para aplicações Spring Boot.",
  "version": "Docker 26.x, Kubernetes 1.31",
  "resumo": [
    "Docker e DevOps são como uma mala pronta para viagem e um maestro orquestrando a sinfonia: Docker empacota aplicações com suas dependências em containers, garantindo consistência entre ambientes como desenvolvimento, teste e produção, enquanto DevOps une desenvolvimento e operações para acelerar entregas com automação, colaboração e monitoramento, sendo fundamentais para sistemas como um e-commerce que precisa de deploy rápido e confiável.",
    "O Docker funciona como uma caixa mágica: cria imagens imutáveis que contêm o código e as dependências de uma aplicação, como uma app Spring Boot, e instancias essas imagens em containers executáveis, permitindo que múltiplas instâncias rodem de forma isolada e consistente, ideal para júniores testarem localmente antes de subir para produção em um ambiente de microserviços.",
    "Docker Compose atua como um plano de voo coordenado: gerencia múltiplos containers, como uma app Spring Boot junto com um banco de dados PostgreSQL, através de um arquivo YAML, facilitando testes locais e simulações de ambientes completos, o que é perfeito para desenvolvedores que precisam replicar um sistema de e-commerce com várias camadas em suas máquinas.",
    "A cultura DevOps é como uma equipe afinada: combina práticas como Integração Contínua (CI) e Entrega Contínua (CD) para automatizar builds, testes e deploys, promovendo colaboração entre times de desenvolvimento e operações, sendo essencial em cenários onde um sistema de reservas precisa de atualizações frequentes sem interrupções.",
    "CI/CD é o coração pulsante dessa orquestração: CI executa testes automaticamente a cada commit, garantindo qualidade imediata, enquanto CD automatiza a entrega ou implantação em produção, reduzindo erros humanos e acelerando releases, como em um pipeline que empacota uma app Spring Boot e a deploya em um servidor após validação.",
    "Kubernetes entra como o maestro principal: orquestra containers em clusters, gerenciando escalabilidade, disponibilidade e deploys automáticos através de pods, que são unidades mínimas contendo containers, sendo ideal para escalar um serviço de chat em tempo real que precisa suportar milhares de usuários simultâneos.",
    "A mensageria, como Kafka ou RabbitMQ, funciona como um correio eficiente: permite comunicação assíncrona entre microserviços, enviando e recebendo mensagens para processar tarefas como atualizações de estoque em um e-commerce, garantindo que os serviços permaneçam desacoplados e resilientes.",
    "Monitoramento e logging são os olhos e ouvidos do sistema: ferramentas como Prometheus coletam métricas de performance, enquanto o ELK Stack rastreia eventos e erros, sendo cruciais para diagnosticar problemas em produção, como falhas em um serviço de pagamento, e manter a observabilidade em arquiteturas complexas.",
    "Infraestrutura como Código (IaC) é como um blueprint digital: usa ferramentas como Terraform para definir servidores, redes e containers em código, assegurando consistência e repetibilidade na implantação de ambientes, como configurar um cluster Kubernetes para uma app Spring Boot em cloud.",
    "Em cenários reais, Docker empacota apps para deploy contínuo, Kubernetes escala serviços em produção, e mensageria suporta integrações assíncronas, enquanto monitoramento e IaC garantem visibilidade e automação, sendo amplamente adotados em empresas que operam sistemas distribuídos como plataformas de streaming.",
    "Para júniores, pratique criando uma imagem Docker com um Dockerfile simples, configure um Docker Compose com app e banco, e explore CI/CD com GitHub Actions, começando com projetos pequenos como uma API de usuários antes de mergulhar em Kubernetes ou mensageria.",
    "Cuidado com a sobrecarga de containers, que pode consumir recursos se mal gerenciada, valide pipelines CI/CD para evitar deploys quebrados, e documente configurações IaC para facilitar a colaboração, especialmente em times que lidam com múltiplos ambientes.",
    "Combine Docker com Kubernetes para escalabilidade, use mensageria para desacoplamento, e integre monitoramento com logs centralizados, adotando boas práticas como versionamento de imagens e automação de testes para suportar a evolução de sistemas em produção."
  ],
  "subsections": [
    {
      "subtitle": "O que é Docker?",
      "description": "Definição inicial de containers.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "O Docker garante consistência entre ambientes ao empacotar a aplicação e suas dependências em imagens, replicando o mesmo ambiente de desenvolvimento para teste e produção, como uma app Spring Boot que roda igual em todas as etapas.",
          "code": "docker run -d -p 8080:8080 spring-app\n# Executa container de uma app Spring Boot na porta 8080",
          "interview_question": "Como o Docker garante consistência entre ambientes?",
          "references": ["https://docs.docker.com/get-started/"]
        }
      ]
    },
    {
      "subtitle": "Imagem vs Container",
      "description": "Diferença entre modelos e instâncias.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Criar uma imagem Docker para uma app Java envolve escrever um Dockerfile que copia o JAR e define a execução com OpenJDK, construindo com 'docker build' e rodando com 'docker run', permitindo deploy consistente.",
          "code": "# Dockerfile para Spring Boot\nFROM openjdk:21\nCOPY target/app.jar app.jar\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n# Comandos\n docker build -t minha-app .\n docker run -d minha-app",
          "interview_question": "Como criar uma imagem Docker para uma aplicação Java?",
          "references": ["https://docs.docker.com/engine/reference/builder/"]
        }
      ]
    },
    {
      "subtitle": "Docker Compose",
      "description": "Orquestração de múltiplos containers.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Docker Compose ajuda no desenvolvimento local ao gerenciar uma app Spring Boot com um banco PostgreSQL em um único comando 'docker-compose up', simulando um ambiente completo e facilitando testes de integração.",
          "code": "# docker-compose.yml\nversion: '3.8'\nservices:\n  app:\n    image: minha-app\n    ports:\n      - \"8080:8080\"\n  db:\n    image: postgres:16\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n# Inicia com: docker-compose up",
          "interview_question": "Como o Docker Compose ajuda no desenvolvimento local de uma app Spring Boot?",
          "references": ["https://docs.docker.com/compose/"]
        }
      ]
    },
    {
      "subtitle": "DevOps",
      "description": "Cultura e práticas para entrega contínua.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "A cultura DevOps melhora a colaboração ao alinhar Dev e Ops com automação e monitoramento, reduzindo silos e acelerando entregas, como em um time que deploya uma app Spring Boot sem conflitos.",
          "code": "# Exemplo de pipeline CI/CD (pseudo-código)\nbuild: mvn clean package\ntest: mvn test\ndeploy: docker push minha-app",
          "interview_question": "Como a cultura DevOps melhora a colaboração entre times?",
          "references": ["https://aws.amazon.com/devops/what-is-devops/"]
        }
      ]
    },
    {
      "subtitle": "CI/CD",
      "description": "Integração e entrega contínuas.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Continuous Delivery prepara o código para deploy manual após testes, enquanto Continuous Deployment automatiza até a produção, sendo CD ideal para apps Spring Boot que precisam de releases frequentes sem intervenção.",
          "code": "# .github/workflows/ci.yml (GitHub Actions)\nname: CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: mvn clean test",
          "interview_question": "Qual a diferença entre Continuous Delivery e Continuous Deployment?",
          "references": ["https://docs.github.com/en/actions"]
        }
      ]
    },
    {
      "subtitle": "Kubernetes (Básico)",
      "description": "Orquestração de containers em escala.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Kubernetes difere do Docker Compose ao gerenciar clusters em escala, com pods orquestrados para alta disponibilidade, enquanto Compose é local, sendo Kubernetes mais adequado para deploy de uma app Spring Boot em produção.",
          "code": "# Exemplo de pod Kubernetes\napiVersion: v1\nkind: Pod\nmetadata:\n  name: spring-app\nspec:\n  containers:\n  - name: app\n    image: minha-app:latest\n    ports:\n    - containerPort: 8080",
          "interview_question": "Como o Kubernetes diferencia-se do Docker Compose?",
          "references": ["https://kubernetes.io/docs/concepts/"]
        }
      ]
    },
    {
      "subtitle": "Monitoramento e Logging",
      "description": "Observabilidade em aplicações.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Monitoramento é crítico em microserviços para rastrear métricas como latência, enquanto logging ajuda a diagnosticar erros, como falhas em uma app Spring Boot, garantindo visibilidade em sistemas distribuídos.",
          "code": "# Configuração Prometheus (prometheus.yml)\nscrape_configs:\n  - job_name: 'spring-app'\n    static_configs:\n    - targets: ['app:8080']\n# Habilita actuator no Spring Boot\nmanagement.endpoints.web.exposure.include=health,metrics",
          "interview_question": "Por que monitoramento é crítico em arquiteturas de microserviços?",
          "references": ["https://prometheus.io/docs/introduction/overview/"]
        }
      ]
    },
    {
      "subtitle": "Infraestrutura como Código (IaC)",
      "description": "Automação de infraestrutura.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "IaC melhora a implantação em cloud ao definir recursos como containers em código com Terraform, assegurando que ambientes sejam replicados consistentemente, como um cluster para uma app Spring Boot.",
          "code": "# Terraform para criar um container ECS\nresource \"aws_ecs_task_definition\" \"app\" {\n  family = \"spring-app\"\n  container_definitions = jsonencode([{\n    name = \"app\"\n    image = \"minha-app:latest\"\n  }])\n}",
          "interview_question": "Como o IaC melhora a implantação de aplicações em cloud?",
          "references": ["https://www.terraform.io/docs"]
        }
      ]
    }
  ]
}