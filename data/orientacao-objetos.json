{
  "title": "Orientação a Objetos",
  "description": "Princípios e práticas de OOP em Java.",
  "subsections": [
    {
      "subtitle": "O que é Programação Orientada a Objetos (POO)?",
      "description": "Definição e propósito da POO.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "POO é um paradigma de programação baseado em objetos que representam entidades do mundo real, combinando dados (atributos) e comportamentos (métodos). Ela facilita a organização, a reutilização e a manutenção do código.",
          "code": "class Carro {\n  String modelo;\n  void acelerar(){ System.out.println(\"Vruum!\"); }\n}",
          "interview_question": "Explique com suas palavras o que é POO."
        }
      ]
    },
    {
      "subtitle": "Pilares da OOP",
      "description": "Encapsulamento, herança, polimorfismo e abstração.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Encapsulamento protege dados com getters e setters. Herança permite reutilizar código e especializar comportamentos. Polimorfismo possibilita tratar objetos diferentes de forma uniforme. Abstração foca no essencial, escondendo detalhes de implementação.",
          "code": "class Animal { void som(){} }\nclass Cachorro extends Animal { void som(){ System.out.println(\"Au\"); } }",
          "interview_question": "Explique os quatro pilares da orientação a objetos."
        }
      ]
    },
    {
      "subtitle": "Classe Abstrata vs Interface",
      "description": "Diferença de uso entre abstrações.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Classes abstratas permitem herança parcial, podendo conter atributos e métodos implementados ou abstratos. Interfaces definem contratos que podem ser implementados por várias classes, permitindo múltipla herança de comportamento.",
          "code": "abstract class Forma { abstract double area(); }\ninterface Desenhavel { void desenhar(); }",
          "interview_question": "Quando usar classe abstrata em vez de interface?"
        }
      ]
    },
    {
      "subtitle": "Overloading vs Overriding",
      "description": "Duas formas de polimorfismo.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Overloading permite métodos com mesmo nome mas assinaturas diferentes na mesma classe. Overriding redefine o comportamento de um método herdado para adequar à subclasse.",
          "code": "class Calc {\n int soma(int a,int b){return a+b;}\n double soma(double a,double b){return a+b;}\n}\nclass Filho extends Calc{\n @Override int soma(int a,int b){return a+b+1;}\n}",
          "interview_question": "Qual a diferença entre overloading e overriding?"
        }
      ]
    },
    {
      "subtitle": "Imutabilidade e Record",
      "description": "Modelos de objetos imutáveis.",
      "examples": [
        {
          "title": "Explicação",
          "explanation": "Objetos imutáveis não podem ter seu estado alterado após a criação, facilitando concorrência e previsibilidade. Desde Java 14, records simplificam a criação de classes de transporte de dados imutáveis.",
          "code": "public record Usuario(String nome,int idade){}",
          "interview_question": "Qual a vantagem de usar objetos imutáveis?"
        }
      ]
    }
  ]
}
